<application>
  <component name="AppStorage">
    <histories>
      <item value="* Represents a supplier of results.  *  * &lt;p&gt;There is no requirement that a new or distinct result be returned each  * time the supplier is invoked.  *  * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;  * whose functional method is {@link #get()}.  *  * @param &lt;T&gt; the type of results supplied by this supplier  *" />
      <item value="Represents a supplier of results." />
      <item value="&lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values      *     {@code x} and {@code y}, multiple invocations of      *     {@code x.equals(y)} consistently return {@code true}      *     or consistently return {@code false}, provided no      *     information used in {@code equals} comparisons on the      *     objects is modified." />
      <item value="reflexive" />
      <item value="Returns a predicate that tests if two arguments are equal according      * to {@link Objects#equals(Object, Object)}." />
      <item value=" Returns a predicate that represents the logical negation of this      * predicate." />
      <item value="Returns a composed predicate that represents a short-circuiting logical      * AND of this predicate and another.  When evaluating the composed      * predicate, if this predicate is {@code false}, then the {@code other}      * predicate is not evaluated." />
      <item value="compose" />
      <item value="composed" />
      <item value=" * Evaluates this predicate on the given argument." />
      <item value="predicate" />
      <item value="--- title: Java Function接口 date: 2020-02-26 15:00:05 categories: java tags:  ---  ### Function接口  #### 概述  Function接口时java 1.8添加的一个新的特性，使用`@FunctionalInterface`进行标注，表示是函数式接口，具体来说，所有标注了该注解的接口都将能用在lambda表达式上  类源码：  ```java @FunctionalInterface //接受T对象，返回R对象 public interface Function&lt;T, R&gt; {   //对参数应用此函数   R apply(T t);     //返回一个组合函数，该函数首先将before函数应用于其输入，然后将此函数应用与结果   default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {         Objects.requireNonNull(before);         return (V v) -&gt; apply(before.apply(v));     }     //返回一个组合函数，该函数首先将此函数应用于*输入，然后将 after函数应用于结果   default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {         Objects.requireNonNull(after);         return (T t) -&gt; after.apply(apply(t));     }     //返回始终返回其输入参数的函数   static &lt;T&gt; Function&lt;T, T&gt; identity() {         return t -&gt; t;     } }  ```  #### 使用  ##### apply()  Function是一个泛型接口，其中定义了两个泛型参数T和R，在Function中，T代表输入参数，R代表返回的结果；  Function中没有具体的操作，具体的操作需要我们去为它指定，因此`apply()`具体返回的结果取决于传入的lambda表达式，例如：  ```java public void test(){ &#9;Function&lt;Integet,Integer&gt; test=i-&gt;i+1; &#9;test.apply(1) } //结果为2 ```  用lambda表达式定义了一个自增的行为，对于参数1执行`apply`,最后返回2  再[例如](https://www.cnblogs.com/rever/p/9725173.html)：  ```java public void test(){     //定义不同的函数     Function&lt;Integer,Integer&gt; test1=i-&gt;i+1;     Function&lt;Integer,Integer&gt; test2=i-&gt;i*i;     System.out.println(calculate(test1,5));     System.out.println(calculate(test2,5)); } // public static Integer calculate(Function&lt;Integer,Integer&gt; test,Integer number){     return test.apply(number); } /** print:6*/ /** print:25*/ ```  通过定义不同的Function，并传入，实现了在同一个方法中实现不同的操作，称为逻辑的复用  实际使用中可能需要多个函数对于一个参数先后进行操作，[例如：](https://www.cnblogs.com/rever/p/9725173.html)  ```java public void test(){     Function&lt;Integer,Integer&gt; A=i-&gt;i+1;     Function&lt;Integer,Integer&gt; B=i-&gt;i*i;     //先使用A对参数进行处理，在使用B对A处理的结果再进行处理     System.out.println(&quot;F1:&quot;+B.apply(A.apply(5)));     //先使用B对参数进行处理，在使用A对B处理的结果再进行处理     System.out.println(&quot;F2:&quot;+A.apply(B.apply(5))); } /** F1:36 */ /** F2:26 */ ```  ##### compose和andThen  为了简化多个连续的函数操作，提供了这两种方法，返回的均为一个Function  如上面源码，compose接受一个Fnuncton参数，先执行传入参数的apply，再执行本身的apply；andThen则执行顺序相反，即  ```java B.apply(A.apply(5)); //等价于 B.compose(A).apply(5); //或 A.andThen(B).apply(5);  A.apply(B.apply(5)); //等价于 B.andThen(A).apply(5); //或 A.compose(B).apply(5); ```  " />
      <item value="自增" />
      <item value="自加" />
      <item value="Returns a function that always returns its input argument." />
      <item value="Returns a composed function that first applies this function to      * its input, and then applies the {@code after} function to the result.      * If evaluation of either function throws an exception, it is relayed to      * the caller of the composed function." />
      <item value="Returns a composed function that first applies the {@code before}      * function to its input, and then applies this function to the result.      * If evaluation of either function throws an exception, it is relayed to      * the caller of the composed function." />
      <item value="deferred" />
      <item value="eturns 0 if the arguments are identical and {@code      * c.compare(a, b)} otherwise." />
      <item value="refer" />
      <item value="reference" />
      <item value="Represent" />
      <item value="invoked" />
      <item value="模板下载" />
      <item value="(immutable" />
      <item value="enumeration" />
      <item value="Returns a dynamically typesafe view of the specified collection" />
      <item value="pass it through" />
      <item value="pass through" />
      <item value="the backing collection" />
      <item value="preserve the contracts" />
      <item value="The returned collection does &lt;i&gt;not&lt;/i&gt; pass the hashCode and equals      * operations through to the backing collection" />
      <item value="Rotates the elements in the specified list by the specified distance." />
      <item value="induced by" />
      <item value="the specified source of      * randomness" />
      <item value="permute" />
      <item value="permutes" />
      <item value="ascending order" />
      <item value="Suppresses default constructor, ensuring non-instantiability." />
      <item value="Replaces the last element returned by {@link #next} or      * {@link #previous} with the specified element (optional operation).      * This call can be made only if neither {@link #remove} nor {@link      * #add} have been called after the last call to {@code next} or      * {@code previous}." />
      <item value="the array into which the elements of this collection are to be      *        stored, if it is big enough; otherwise, a new array of the same      *        runtime type is allocated for this purpose." />
      <item value="allocated " />
      <item value="stipulations" />
      <item value="定级备案单元名称" />
      <item value="用途" />
      <item value="开放" />
      <item value="开放用途" />
      <item value="定级级别" />
      <item value="定级名称" />
      <item value="责任人" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="6" />
        <entry key="ENGLISH" value="6" />
      </map>
    </option>
  </component>
</application>